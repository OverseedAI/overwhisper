name: Build and Release DMG

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version number (e.g., 1.0.0)'
        required: true

env:
  SCHEME: Overwhisper
  PRODUCT_NAME: Overwhisper

jobs:
  build:
    runs-on: macos-14

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable

      - name: Install Dependencies
        run: brew install create-dmg

      - name: Import Code Signing Certificate
        env:
          CERTIFICATE_BASE64: ${{ secrets.APPLE_DEVELOPER_CERTIFICATE_P12_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.APPLE_DEVELOPER_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ github.run_id }}
        run: |
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          echo "$CERTIFICATE_BASE64" | base64 --decode > $RUNNER_TEMP/certificate.p12
          security import $RUNNER_TEMP/certificate.p12 -P "$CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

      - name: Determine Version
        id: version
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "version=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT
          fi

      - name: Update Version
        run: |
          /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString ${{ steps.version.outputs.version }}" Overwhisper/Info.plist
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion ${{ github.run_number }}" Overwhisper/Info.plist

      - name: Build and Archive
        run: |
          xcodebuild archive \
            -project Overwhisper.xcodeproj \
            -scheme $SCHEME \
            -destination "generic/platform=macOS" \
            -archivePath $RUNNER_TEMP/Overwhisper.xcarchive \
            DEVELOPMENT_TEAM="${{ secrets.APPLE_TEAM_ID }}" \
            CODE_SIGN_IDENTITY="-" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO \
            ENABLE_HARDENED_RUNTIME=YES

      - name: Export Archive (unsigned)
        run: |
          # Copy the app from archive without using xcodebuild export
          # This avoids signing issues with SPM dependencies
          mkdir -p $RUNNER_TEMP/Export
          cp -R "$RUNNER_TEMP/Overwhisper.xcarchive/Products/Applications/$PRODUCT_NAME.app" "$RUNNER_TEMP/Export/"

      - name: Sign with Hardened Runtime
        run: |
          APP_PATH="$RUNNER_TEMP/Export/$PRODUCT_NAME.app"
          IDENTITY="Developer ID Application"
          ENTITLEMENTS="Overwhisper/Overwhisper.entitlements"

          # Find and sign all frameworks and dylibs first (inside out signing)
          find "$APP_PATH" -type f -name "*.dylib" -o -name "*.framework" | while read -r item; do
            codesign --force --options runtime --sign "$IDENTITY" "$item" 2>/dev/null || true
          done

          # Sign all executables in Frameworks
          if [ -d "$APP_PATH/Contents/Frameworks" ]; then
            find "$APP_PATH/Contents/Frameworks" -type f -perm +111 | while read -r item; do
              codesign --force --options runtime --sign "$IDENTITY" "$item" 2>/dev/null || true
            done
          fi

          # Sign the main executable with entitlements and hardened runtime
          codesign --force --options runtime --entitlements "$ENTITLEMENTS" --sign "$IDENTITY" "$APP_PATH"

          # Verify the signature
          codesign --verify --deep --strict --verbose=2 "$APP_PATH"

      - name: Notarize App
        run: |
          ditto -c -k --keepParent "$RUNNER_TEMP/Export/$PRODUCT_NAME.app" "$RUNNER_TEMP/$PRODUCT_NAME.zip"

          # Submit and capture submission ID
          SUBMIT_OUTPUT=$(xcrun notarytool submit "$RUNNER_TEMP/$PRODUCT_NAME.zip" \
            --apple-id "${{ secrets.APPLE_ID }}" \
            --password "${{ secrets.APPLE_ID_PASSWORD }}" \
            --team-id "${{ secrets.APPLE_TEAM_ID }}" \
            --wait 2>&1) || true

          echo "$SUBMIT_OUTPUT"

          # Extract submission ID and check status
          SUBMISSION_ID=$(echo "$SUBMIT_OUTPUT" | grep "id:" | head -1 | awk '{print $2}')

          if echo "$SUBMIT_OUTPUT" | grep -q "status: Invalid"; then
            echo "Notarization failed. Fetching log..."
            xcrun notarytool log "$SUBMISSION_ID" \
              --apple-id "${{ secrets.APPLE_ID }}" \
              --password "${{ secrets.APPLE_ID_PASSWORD }}" \
              --team-id "${{ secrets.APPLE_TEAM_ID }}"
            exit 1
          fi

          xcrun stapler staple "$RUNNER_TEMP/Export/$PRODUCT_NAME.app"

      - name: Create DMG
        run: |
          VERSION=${{ steps.version.outputs.version }}

          create-dmg \
            --volname "$PRODUCT_NAME" \
            --window-pos 200 120 \
            --window-size 600 400 \
            --icon-size 100 \
            --icon "$PRODUCT_NAME.app" 150 190 \
            --hide-extension "$PRODUCT_NAME.app" \
            --app-drop-link 450 190 \
            "$RUNNER_TEMP/$PRODUCT_NAME-$VERSION.dmg" \
            "$RUNNER_TEMP/Export/$PRODUCT_NAME.app" || true

          xcrun notarytool submit "$RUNNER_TEMP/$PRODUCT_NAME-$VERSION.dmg" \
            --apple-id "${{ secrets.APPLE_ID }}" \
            --password "${{ secrets.APPLE_ID_PASSWORD }}" \
            --team-id "${{ secrets.APPLE_TEAM_ID }}" \
            --wait

          xcrun stapler staple "$RUNNER_TEMP/$PRODUCT_NAME-$VERSION.dmg"
          mv "$RUNNER_TEMP/$PRODUCT_NAME-$VERSION.dmg" .

      - name: Sign DMG for Sparkle
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
        run: |
          VERSION=${{ steps.version.outputs.version }}
          DMG_PATH="$PRODUCT_NAME-$VERSION.dmg"

          # Get Sparkle tools from resolved packages
          SPARKLE_BIN=$(find ~/Library/Developer/Xcode/DerivedData -path "*/SourcePackages/artifacts/sparkle/Sparkle/bin" -type d | head -1)

          if [ -z "$SPARKLE_BIN" ]; then
            echo "Sparkle tools not found, skipping signature"
            exit 0
          fi

          # Sign the DMG and get the signature
          echo "$SPARKLE_PRIVATE_KEY" > /tmp/sparkle_key
          SIGNATURE=$("$SPARKLE_BIN/sign_update" "$DMG_PATH" -f /tmp/sparkle_key)
          rm /tmp/sparkle_key

          echo "SPARKLE_SIGNATURE=$SIGNATURE" >> $GITHUB_ENV
          echo "Sparkle signature: $SIGNATURE"

      - name: Generate Appcast Entry
        run: |
          VERSION=${{ steps.version.outputs.version }}
          DMG_PATH="$PRODUCT_NAME-$VERSION.dmg"
          DMG_SIZE=$(stat -f%z "$DMG_PATH")
          DOWNLOAD_URL="https://github.com/OverseedAI/overwhisper/releases/download/v$VERSION/$DMG_PATH"
          PUB_DATE=$(date -u +"%a, %d %b %Y %H:%M:%S +0000")

          # Create appcast item
          cat > appcast_item.xml << EOF
          <item>
            <title>Version $VERSION</title>
            <pubDate>$PUB_DATE</pubDate>
            <sparkle:version>${{ github.run_number }}</sparkle:version>
            <sparkle:shortVersionString>$VERSION</sparkle:shortVersionString>
            <enclosure
              url="$DOWNLOAD_URL"
              length="$DMG_SIZE"
              type="application/octet-stream"
              sparkle:edSignature="$SPARKLE_SIGNATURE"
            />
          </item>
          EOF

          cat appcast_item.xml

      - name: Upload DMG Artifact
        uses: actions/upload-artifact@v4
        with:
          name: Overwhisper-${{ steps.version.outputs.version }}.dmg
          path: "*.dmg"

      - name: Upload Appcast Item
        uses: actions/upload-artifact@v4
        with:
          name: appcast-item-${{ steps.version.outputs.version }}
          path: appcast_item.xml

      - name: Create GitHub Release
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v1
        with:
          files: "*.dmg"
          draft: false
          prerelease: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update Appcast
        if: startsWith(github.ref, 'refs/tags/')
        env:
          VERSION: ${{ steps.version.outputs.version }}
          BUILD_NUMBER: ${{ github.run_number }}
        run: |
          DMG_PATH="$PRODUCT_NAME-$VERSION.dmg"
          DMG_SIZE=$(stat -f%z "$DMG_PATH")
          DOWNLOAD_URL="https://github.com/OverseedAI/overwhisper/releases/download/v$VERSION/$DMG_PATH"
          PUB_DATE=$(date -u +"%a, %d %b %Y %H:%M:%S +0000")
          ED_SIG=$(echo "$SPARKLE_SIGNATURE" | grep -o 'edSignature="[^"]*"' | cut -d'"' -f2)

          export DMG_SIZE DOWNLOAD_URL PUB_DATE ED_SIG

          python3 -c "
          import os

          version = os.environ['VERSION']
          build = os.environ['BUILD_NUMBER']
          size = os.environ['DMG_SIZE']
          url = os.environ['DOWNLOAD_URL']
          date = os.environ['PUB_DATE']
          sig = os.environ['ED_SIG']

          item = f'''    <item>
            <title>Version {version}</title>
            <pubDate>{date}</pubDate>
            <sparkle:version>{build}</sparkle:version>
            <sparkle:shortVersionString>{version}</sparkle:shortVersionString>
            <enclosure
              url=\"{url}\"
              length=\"{size}\"
              type=\"application/octet-stream\"
              sparkle:edSignature=\"{sig}\"
            />
          </item>'''

          with open('docs/appcast.xml', 'r') as f:
              content = f.read()

          content = content.replace('</language>', '</language>\n' + item)

          with open('docs/appcast.xml', 'w') as f:
              f.write(content)
          "

          cat docs/appcast.xml

      - name: Commit Appcast Update
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add docs/appcast.xml
          git commit -m "Update appcast for v${{ steps.version.outputs.version }}"
          git push origin HEAD:main
